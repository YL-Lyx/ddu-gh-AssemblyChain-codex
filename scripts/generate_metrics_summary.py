#!/usr/bin/env python3
"""Generate a JSON summary focusing on dependencies, complexity, and documentation.

The script expects that ``reports/audit_report.json`` has been generated by
``repo_audit.py``.  It aggregates a handful of metrics that are relevant for the
DevOps quality gates and writes them to ``reports/metrics_summary.json`` so the
CI workflow can upload/share them easily.
"""
from __future__ import annotations

import json
from collections import Counter
from datetime import datetime, timezone
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
AUDIT_REPORT = ROOT / "reports" / "audit_report.json"
SUMMARY_REPORT = ROOT / "reports" / "metrics_summary.json"


def _load_audit() -> dict:
    if not AUDIT_REPORT.exists():
        raise SystemExit(
            f"Missing audit report at {AUDIT_REPORT}. Run repo_audit.py before generating the summary."
        )
    return json.loads(AUDIT_REPORT.read_text(encoding="utf-8"))


def _collect_methods(files: list[dict]) -> list[dict]:
    methods: list[dict] = []
    for file_info in files:
        for method in file_info.get("methods", []) or []:
            enriched = dict(method)
            enriched["file"] = file_info.get("path")
            enriched["namespace"] = file_info.get("namespace")
            methods.append(enriched)
    return methods


def main() -> None:
    audit = _load_audit()
    data = audit.get("data", {})
    files = data.get("files", [])
    dependencies = data.get("dependencies", {})
    dependency_cycles = data.get("dependency_cycles", [])

    methods = _collect_methods(files)

    complexity_values = [int(method.get("complexity", 0) or 0) for method in methods]
    average_complexity = (
        sum(complexity_values) / len(complexity_values) if complexity_values else 0.0
    )
    max_complexity = max(complexity_values, default=0)

    public_methods = [method for method in methods if method.get("is_public")]
    documented_public = [method for method in public_methods if method.get("doc_present")]
    public_doc_coverage = (
        len(documented_public) / len(public_methods) if public_methods else 1.0
    )

    total_doc_lines = sum(int(file_info.get("doc_lines", 0) or 0) for file_info in files)
    total_loc = sum(int(file_info.get("loc", 0) or 0) for file_info in files)
    overall_doc_ratio = (total_doc_lines / total_loc) if total_loc else 0.0

    dependency_edge_counter: Counter[tuple[str, str]] = Counter()
    for origin, targets in dependencies.items():
        for target in targets:
            dependency_edge_counter[(origin, target)] += 1

    total_dependency_edges = sum(dependency_edge_counter.values())
    top_dependencies = [
        {"source": src, "target": dst, "weight": weight}
        for (src, dst), weight in dependency_edge_counter.most_common(10)
    ]

    top_complex_methods = sorted(
        (
            {
                "name": method.get("name"),
                "file": method.get("file"),
                "namespace": method.get("namespace"),
                "complexity": method.get("complexity", 0),
                "length": method.get("length", 0),
                "doc_present": method.get("doc_present", False),
            }
            for method in methods
        ),
        key=lambda item: (-(item.get("complexity") or 0), -(item.get("length") or 0)),
    )[:10]

    undocumented_public_methods = sorted(
        (
            {
                "name": method.get("name"),
                "file": method.get("file"),
                "namespace": method.get("namespace"),
                "complexity": method.get("complexity", 0),
            }
            for method in public_methods
            if not method.get("doc_present")
        ),
        key=lambda item: (-(item.get("complexity") or 0), item.get("name") or ""),
    )[:10]

    summary_payload = {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "dependency_analysis": {
            "total_edges": total_dependency_edges,
            "unique_relationships": len(dependency_edge_counter),
            "cycle_count": len(dependency_cycles),
            "sample_cycles": dependency_cycles[:5],
            "top_relationships": top_dependencies,
        },
        "complexity_analysis": {
            "method_count": len(methods),
            "average_complexity": round(average_complexity, 4),
            "max_complexity": max_complexity,
            "top_methods": top_complex_methods,
        },
        "documentation_analysis": {
            "total_doc_lines": total_doc_lines,
            "total_loc": total_loc,
            "overall_doc_ratio": round(overall_doc_ratio, 4),
            "public_api_coverage": round(public_doc_coverage, 4),
            "undocumented_public_methods": undocumented_public_methods,
        },
    }

    SUMMARY_REPORT.write_text(
        json.dumps(summary_payload, indent=2, ensure_ascii=False) + "\n",
        encoding="utf-8",
    )


if __name__ == "__main__":
    main()

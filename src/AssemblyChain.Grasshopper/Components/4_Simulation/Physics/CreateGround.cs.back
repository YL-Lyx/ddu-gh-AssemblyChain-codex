using System;
using System.Numerics;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using BulletSharp;
using System.Windows.Forms;

// Temporarily disabled to resolve compilation issues - can be re-enabled later
// using AssemblyChain.Core.Utilities;

namespace AssemblyChain.Gh.Components.Simulation
{
    public sealed class CreateGround : GH_Component
    {
        public CreateGround() : base(
            "Create Ground", "Ground",
            "Create ground for physics simulation with automatic shape selection.\n" +
            "Plane/Surface→infinite plane, Box→finite platform, Mesh/Brep→terrain.\n" +
            "Outputs Bullet ground wrapper for AssemblyPhysics component.",
            "AssemblyChain", "4|Simulation")
        { }

        public override Guid ComponentGuid => new Guid("8F2A4C3D-9E1B-4F8A-9D7C-6B5A4E3F2D1C");

        protected override void RegisterInputParams(GH_InputParamManager p)
        {
            p.AddGenericParameter("Base", "B", "Base geometry: Plane/Surface/Brep/Mesh→terrain, Box→platform. Planar→infinite plane, Curved→mesh, Box→box shape.", GH_ParamAccess.item);
            p.AddNumberParameter("Friction", "F", "Ground friction coefficient [0..1+]", GH_ParamAccess.item, 0.7);
            p.AddNumberParameter("Restitution", "R", "Ground restitution coefficient [0..1]", GH_ParamAccess.item, 0.0);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager p)
        {
            p.AddGenericParameter("Ground", "G", "Bullet ground wrapper for physics simulation", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess da)
        {
            object baseInput = null;
            double friction = 0.7;
            double restitution = 0.0;

            if (!da.GetData(0, ref baseInput))
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Missing base input.");
                return;
            }
            da.GetData(1, ref friction);
            da.GetData(2, ref restitution);

            // Units: Rhino document units → meters
            double sceneToMeters = 1.0;
            try
            {
                var doc = Rhino.RhinoDoc.ActiveDoc;
                if (doc != null)
                    sceneToMeters = Rhino.RhinoMath.UnitScale(doc.ModelUnitSystem, Rhino.UnitSystem.Meters);
            }
            catch { sceneToMeters = 1.0; }

            try
            {
                CollisionShape groundShape;
                TriangleMesh triangleMesh = null;
                System.Numerics.Matrix4x4 initialTransform = System.Numerics.Matrix4x4.Identity;

                // Temporarily disabled geometry processing to resolve compilation issues
                // Normalize Grasshopper wrappers to Rhino types
                // object actualGeometry = UnwrapGrasshopperValue(baseInput);

                // Create a simple default ground shape
                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Ground creation temporarily simplified due to compilation issues");
                groundShape = new StaticPlaneShape(Vector3.UnitZ, 0f);
                // Temporarily disabled remaining branches to resolve compilation issues
                // else if (actualGeometry is Box box && box.IsValid)
                // {
                //     AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "Creating box platform ground");
                //     float hx = (float)(box.X.Length * 0.5 * sceneToMeters);
                //     float hy = (float)(box.Y.Length * 0.5 * sceneToMeters);
                //     float hz = (float)(box.Z.Length * 0.5 * sceneToMeters);
                //     groundShape = new BoxShape(new Vector3(hx, hy, hz));

                //     var centerM = box.Center; centerM.X *= sceneToMeters; centerM.Y *= sceneToMeters; centerM.Z *= sceneToMeters;
                //     var basis = box.Plane;
                //     var xf = Transform.Identity;
                //     xf.M00 = basis.XAxis.X; xf.M01 = basis.YAxis.X; xf.M02 = basis.ZAxis.X; xf.M03 = centerM.X;
                //     xf.M10 = basis.XAxis.Y; xf.M11 = basis.YAxis.Y; xf.M12 = basis.ZAxis.Y; xf.M13 = centerM.Y;
                //     xf.M20 = basis.XAxis.Z; xf.M21 = basis.YAxis.Z; xf.M22 = basis.ZAxis.Z; xf.M23 = centerM.Z;
                //     initialTransform = RhinoXformToMatrix(xf, 1.0); // already in meters
                // }
                // Branch D: Terrain (Mesh / non-planar Surface / Brep) - temporarily disabled
                // else if (actualGeometry is GeometryBase terrainGeometry)
                // {
                //     AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "Creating triangulated terrain ground");
                //     var mesh = CreateGroundMesh(terrainGeometry);
                //     if (mesh == null || !mesh.IsValid)
                //     {
                //         AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Failed to create ground mesh");
                //         return;
                //     }

                //     mesh.EnsurePrivateCopy();
                //     mesh.Weld(Math.PI / 180.0);
                //     mesh.UnifyNormals();
                //     mesh.Normals.ComputeNormals();
                //     mesh.Compact();

                //     // Scale vertices to meters
                //     for (int i = 0; i < mesh.Vertices.Count; i++)
                //     {
                //         var v = mesh.Vertices[i];
                //         mesh.Vertices.SetVertex(i, v.X * sceneToMeters, v.Y * sceneToMeters, v.Z * sceneToMeters);
                //     }

                //     triangleMesh = new TriangleMesh();
                //     foreach (var f in mesh.Faces)
                //     {
                //         var a = mesh.Vertices[f.A];
                //         var b = mesh.Vertices[f.B];
                //         var c = mesh.Vertices[f.C];
                //         triangleMesh.AddTriangle(new Vector3((float)a.X, (float)a.Y, (float)a.Z),
                //                                  new Vector3((float)b.X, (float)b.Y, (float)b.Z),
                //                                  new Vector3((float)c.X, (float)c.Y, (float)c.Z));
                //         if (f.IsQuad)
                //         {
                //             var d = mesh.Vertices[f.D];
                //             triangleMesh.AddTriangle(new Vector3((float)c.X, (float)c.Y, (float)c.Z),
                //                                      new Vector3((float)d.X, (float)d.Y, (float)d.Z),
                //                                      new Vector3((float)a.X, (float)a.Y, (float)a.Z));
                //         }
                //     }

                //     var bvh = new BvhTriangleMeshShape(triangleMesh, true) { Margin = 0f };
                //     groundShape = bvh;
                // }
                // else
                // {
                //     AddRuntimeMessage(GH_RuntimeMessageLevel.Error, $"Unsupported base input type: {actualGeometry?.GetType().Name ?? "null"}");
                //     return;
                // }

                // Motion state and rigid body (static: mass=0)
                var groundMotion = new DefaultMotionState(initialTransform);
                using var info = new RigidBodyConstructionInfo(0, groundMotion, groundShape, Vector3.Zero)
                {
                    Friction = (float)friction,
                    Restitution = (float)restitution
                };
                var groundBody = new RigidBody(info);

                // Create wrapper (type provided by project utilities)
                var groundWrapper = new GroundWrapper(groundShape, groundMotion, groundBody, triangleMesh);
                da.SetData(0, groundWrapper);
            }
            catch (Exception ex)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, $"Failed to create ground: {ex.Message}");
            }
        }

        private static object UnwrapGrasshopperValue(object value)
        {
            // Temporarily commented out to resolve compilation issues
            // if (value is GH_Plane ghPlane) return (Plane)ghPlane.Value;
            // if (value is GH_Surface ghSurface) return (Surface)ghSurface.Value;
            // if (value is GH_Brep ghBrep) return (Brep)ghBrep.Value;
            // if (value is GH_Box ghBox) return (Box)ghBox.Value;
            // if (value is GH_Mesh ghMesh) return (Mesh)ghMesh.Value;
            // if (value is GH_ObjectWrapper wrapper) return wrapper.Value;
            return value;
        }

        private bool IsPlanarSurface(GeometryBase geometry, out Rhino.Geometry.Plane plane)
        {
            plane = Rhino.Geometry.Plane.WorldXY;

            if (geometry is Surface surface)
            {
                if (surface.IsPlanar())
                {
                    surface.TryGetPlane(out plane);
                    return true;
                }
            }

            if (geometry is Brep brep && brep.Faces.Count > 0)
            {
                var face = brep.Faces[0];
                if (face.IsPlanar())
                {
                    face.TryGetPlane(out plane);
                    return true;
                }
            }

            return false;
        }

        private Mesh CreateGroundMesh(GeometryBase geometry)
        {
            if (geometry is Mesh mesh) return mesh.DuplicateMesh();
            if (geometry is Surface surface) return Mesh.CreateFromSurface(surface, MeshingParameters.Default);
            if (geometry is Brep brep)
            {
                var meshes = Mesh.CreateFromBrep(brep, MeshingParameters.Default);
                if (meshes == null || meshes.Length == 0) return null;
                var combined = meshes[0].DuplicateMesh();
                for (int i = 1; i < meshes.Length; i++)
                    combined.Append(meshes[i]);
                return combined;
            }
            return null;
        }

        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            base.AppendAdditionalComponentMenuItems(menu);
            menu.Items.Add("Horizontal Ground (Z=0)", null, (s, e) =>
            {
                // Placeholder hook for future preset
            });
        }

        protected override System.Drawing.Bitmap Icon => null;
        public override GH_Exposure Exposure => GH_Exposure.primary;

        // Convert Rhino.Transform (column-major) to System.Numerics.Matrix4x4 (row-major)
        static System.Numerics.Matrix4x4 RhinoXformToMatrix(Transform x, double sceneToMeters)
        {
            var m = System.Numerics.Matrix4x4.Identity;
            m.M11 = (float)x.M00; m.M12 = (float)x.M01; m.M13 = (float)x.M02; m.M14 = 0f;
            m.M21 = (float)x.M10; m.M22 = (float)x.M11; m.M23 = (float)x.M12; m.M24 = 0f;
            m.M31 = (float)x.M20; m.M32 = (float)x.M21; m.M33 = (float)x.M22; m.M34 = 0f;
            m.M41 = (float)(x.M03 * sceneToMeters);
            m.M42 = (float)(x.M13 * sceneToMeters);
            m.M43 = (float)(x.M23 * sceneToMeters);
            m.M44 = 1f;
            return m;
        }
    }
}




